Project (4000p)

---

Documentation (1000p)

1. Language introduction: **Complete** (100p)
2. Specification: **Complete** (600p)
   2.1 Syntax: **Complete** (250p)
   2.1.1 Language tokens: **Complete** (50p)
   2.1.2 Syntax in BNF format: **Complete** (100p)
   2.1.3 Abstract syntax and formation rules: **Complete** (100p)
   2.2 Semantics: **Complete** (350p)
   2.2.1 Statics and typing spelled out: **Complete** (100p)
   2.2.2 Typing expressed using typing rules: **Complete** (50p)
   2.2.3 Dynamics and evaluation spelled out: **Complete** (100p)
   2.2.4 Dynamics expressed using evaluation rules: **Complete** (50p)
   2.2.5 Type safety and computational expressiveness: **Complete** (50p)
3. Standard library reference: **Partial** (50p)
4. Tutorial and exercises: **Complete** (200p)
   4.1 Getting started tutorial/language tour: **Complete** (100p)
   4.2 At least five programming exercises for learning the language: **Complete** (100p)

---

Implementation (3000p)

1. Core language: Commands and operations: **Complete** (1000p)
   1.1 Variables: **Complete** (100p)
   1.2 Let statements/expressions: **Complete** (100p)
   1.3 Output / Printing: **Complete** (100p)
   1.4 Integers and booleans: **Complete** (100p)
   1.5 Internal data types and type literals: **Complete** (100p)
   1.6 Functions: **Complete** (100p)
   1.7 Tuples/pairs: **Complete** (100p)
   1.8 Lists: **Incomplete** (0p)
   1.9 Destructuring data, matching (e.g. with if-then-else): **Complete** (100p)
   1.10 Loops: **Complete** (100p)
   1.11 Bonus: Recursion: **Complete** (B100p)
   1.12 Bonus: Strings and characters: **Complete** (B100p)
   1.13 Bonus: Records and dot-syntax: **Incomplete** (0p)
   1.14 Bonus: Type aliases: **Incomplete** (0p)
2. Core language: Type system: **Partial** (400p)
   2.1 Static type checking: **Complete** (200p)
   2.2 Dynamic type checking: **Incomplete** (0p)
   2.3 Type safety: **Complete** (200p)
   2.4 Type coercions: **Incomplete** (0p)
   2.5 Bonus: Polymorphic type system: **Incomplete** (0p)
   2.6 Bonus: Type constructors: **Incomplete** (0p)
3. Bonus: Language extensibility and modularity: **Partial** (300p)
   3.1 Declarations, modules and imports: **Incomplete** (0p)
   3.2 Comments: **Complete** (B100p)
   3.3 Standard library implementation: **Partial** (B100p)
   3.3.1 Utility functions (e.g. math functions): **Incomplete** (0p)
   3.3.2 Data collections (e.g. lists, maps): **Incomplete** (0p)
   3.4 Custom data types (e.g. structs, classes, enums): **Incomplete** (0p)
   3.5 Higher-order functions: **Incomplete** (0p)
4. Working interpreter (incl. parser): **Complete** (1000p)
   4.1 Interpreting works when code is given as a literal: **Complete** (600p)
   4.2 REPL: **Complete** (100p)
   4.3 Type-safe evaluation: **Complete** (200p)
   4.4 Can run a program from a file: **Complete** (100p)
   4.5 Bonus: Informative error messages: **Incomplete** (0p)
5. Automated tests for language: **Partial** (300p)
6. Code generation (code compiles to another language): **Incomplete** (0p)
